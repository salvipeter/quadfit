#include <cassert>

#include <Eigen/Dense>

#include "multiply.hh"

using namespace Geometry;

// Generated by newton-cotes.jl
// n : 1 - 12; odd n -> exact for degree n; even n -> exact for degree n + 1
static const DoubleMatrix newton_cotes =
  {{},
   {5.0e-1,5.0e-1},
   {3.333333333333333e-1,1.333333333333333e0,3.333333333333333e-1},
   {3.75e-1,1.125e0,1.125e0,3.75e-1},
   {3.111111111111111e-1,1.422222222222222e0,5.333333333333333e-1,
    1.422222222222222e0,3.111111111111111e-1},
   {3.298611111111111e-1,1.302083333333333e0,8.680555555555556e-1,
    8.680555555555556e-1,1.302083333333333e0,3.298611111111111e-1},
   {2.928571428571429e-1,1.542857142857143e0,1.928571428571429e-1,
    1.942857142857143e0,1.928571428571429e-1,1.542857142857143e0,
    2.928571428571429e-1},
   {3.04224537037037e-1,1.449016203703704e0,5.359375e-1,
    1.210821759259259e0,1.210821759259259e0,5.359375e-1,
    1.449016203703704e0,3.04224537037037e-1},
   {2.790828924162258e-1,1.661516754850088e0,-2.618694885361552e-1,
    2.961834215167549e0,-1.281128747795415e0,2.961834215167549e0,
    -2.618694885361552e-1,1.661516754850088e0,2.790828924162258e-1},
   {2.869754464285714e-1,1.581127232142857e0,1.084821428571429e-1,
    1.943035714285714e0,5.803794642857143e-1,5.803794642857143e-1,
    1.943035714285714e0,1.084821428571429e-1,1.581127232142857e0,
    2.869754464285714e-1},
   {2.683414836192614e-1,1.775359414248303e0,-8.104357062690396e-1,
    4.549462882796216e0,-4.351551226551227e0,7.137646304312971e0,
    -4.351551226551227e0,4.549462882796216e0,-8.104357062690396e-1,
    1.775359414248303e0,2.683414836192614e-1},
   {2.742655400315991e-1,1.703408943727954e0,-4.088615497317754e-1,
    3.186240802744709e0,-1.211958980930335e0,1.956905244157848e0,
    1.956905244157848e0,-1.211958980930335e0,3.186240802744709e0,
    -4.088615497317754e-1,1.703408943727954e0,2.742655400315991e-1},
   {2.596738499595643e-1,1.88443328100471e0,-1.443863565006422e0,
    6.797986775129632e0,-9.798067646639075e0,1.665311602683031e1,
    -1.670655744255744e1,1.665311602683031e1,-9.798067646639075e0,
    6.797986775129632e0,-1.443863565006422e0,1.88443328100471e0,
    2.596738499595643e-1}};

static double integrate(const std::function<double(double)> &f,
                        const DoubleVector &intervals,
                        size_t degree) {
  assert(degree <= 12);
  double result = 0;
  size_t n = std::max(1ul, degree % 2 == 0 ? degree : degree - 1);
  for (size_t i = 1; i < intervals.size(); ++i) {
    double sum = 0;
    double h = (intervals[i] - intervals[i-1]) / n;
    for (size_t j = 0; j <= n; ++j)
      sum += f(intervals[i-1] + h * j) * newton_cotes[n][j];
    result += sum * h;
  }
  return result;
}

static BSBasis combineBases(const BSBasis &basis1, const BSBasis &basis2) {
  size_t d1 = basis1.degree();
  size_t d2 = basis2.degree();
  size_t d = d1 + d2;
  const auto &knots1 = basis1.knots();
  const auto &knots2 = basis2.knots();
  size_t n1 = knots1.size() - d1 - 1, n2 = knots2.size() - d2 - 1;
  DoubleVector knots;
  std::fill_n(std::back_inserter(knots), d + 1, knots1.front());
  size_t i1 = d1 + 1, i2 = d2 + 1;
  while (i1 < n1 || i2 < n2) {
    if (knots1[i1] < knots2[i2]) {
      double k = knots1[i1];
      size_t m = 0;
      while (knots1[i1] == k) { m++; i1++; }
      std::fill_n(std::back_inserter(knots), m + d2, k);
    } else if (knots2[i2] < knots1[i1]) {
      double k = knots2[i2];
      size_t m = 0;
      while (knots2[i2] == k) { m++; i2++; }
      std::fill_n(std::back_inserter(knots), m + d1, k);
    } else {
      double k = knots1[i1];
      size_t m1 = 0, m2 = 0;
      while (knots1[i1] == k) { m1++; i1++; }
      while (knots2[i2] == k) { m2++; i2++; }
      std::fill_n(std::back_inserter(knots), d1 + d2 - std::min(d1 - m1, d2 - m2), k);
    }
  }
  std::fill_n(std::back_inserter(knots), d + 1, knots1.back());
  return { d, knots };
}

// The resulting surface is linear in v, with its point- and derivative computed as given.
BSSurface multiplyBSplines(const BSBasis &basis1, const BSBasis &basis2,
                           const std::function<Point3D(double)> &point,
                           const std::function<Vector3D(double)> &derivative) {
  auto basis = combineBases(basis1, basis2);
  size_t d = basis.degree();
  auto N = [&](size_t i, double u) {
    size_t span = basis.findSpan(u);
    if (i + d < span || i > span)
      return 0.0;
    DoubleVector coeff;
    basis.basisFunctions(span, u, coeff);
    return coeff[i+d-span];
  };
  const auto &h1 = point;
  const auto &h2 = derivative;
  const auto &knots = basis.knots();
  DoubleVector intervals = { knots.front() };
  for (double k : knots)
    if (k > intervals.back())
      intervals.push_back(k);
  size_t n = knots.size() - d - 2;
  Eigen::MatrixXd A(n + 1, n + 1), b(n + 1, 6);
  for (size_t i = 0; i <= n; ++i) {
    for (size_t j = 0; j <= n; ++j)
      A(i, j) = integrate([&](double u) { return N(i, u) * N(j, u); }, intervals, 2 * d);
    for (size_t j = 0; j < 3; ++j) {
      b(i, j) = integrate([&](double u) { return h1(u)[j] * N(i, u); }, intervals, 2 * d);
      b(i, 3 + j) = integrate([&](double u) { return h2(u)[j] * N(i, u); }, intervals, 2 * d);
    }
  }
  Eigen::MatrixXd x = A.fullPivLu().solve(b);
  PointVector cpts(2 * (n + 1));
  BSSurface result(d, 1, knots, { 0, 0, 1, 1 }, cpts);
  for (size_t i = 0; i <= n; ++i) {
    result.controlPoint(i, 0) = Vector3D(x(i, 0), x(i, 1), x(i, 2));
    result.controlPoint(i, 1) = Vector3D(x(i, 0) + x(i, 3), x(i, 1) + x(i, 4), x(i, 2) + x(i, 5));
  }
  return result;
}
